/*!
 * VERSION: 0.0.3
 * DATE: 2017-06-22
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2017, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */
var _gsScope = (typeof module !== "undefined" && module.exports && typeof global !== "undefined") ? global : this || window;
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
    "use strict";

    var _numExp = /(\d|\.)+/g,
        _colorLookup = {
            aqua: [0, 255, 255],
            lime: [0, 255, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, 255],
            navy: [0, 0, 128],
            white: [255, 255, 255],
            fuchsia: [255, 0, 255],
            olive: [128, 128, 0],
            yellow: [255, 255, 0],
            orange: [255, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [255, 0, 0],
            pink: [255, 192, 203],
            cyan: [0, 255, 255],
            transparent: [255, 255, 255, 0]
        },
        _parseColor = function(color) {
            if (color === "" || color == null || color === "none") {
                return _colorLookup.transparent;
            } else if (_colorLookup[color]) {
                return _colorLookup[color];
            } else if (typeof(color) === "number") {
                return [color >> 16, (color >> 8) & 255, color & 255];
            } else if (color.charAt(0) === "#") {
                if (color.length === 4) { //for shorthand like #9F0
                    color = "#" + color.charAt(1) + color.charAt(1) + color.charAt(2) + color.charAt(2) + color.charAt(3) + color.charAt(3);
                }
                color = parseInt(color.substr(1), 16);
                return [color >> 16, (color >> 8) & 255, color & 255];
            }
            return color.match(_numExp) || _colorLookup.transparent;
        },

        _idMatrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
        _lumR = 0.212671,
        _lumG = 0.715160,
        _lumB = 0.072169,

        _applyMatrix = function(m, m2) {
            if (!(m instanceof Array) || !(m2 instanceof Array)) {
                return m2;
            }
            var temp = [],
                i = 0,
                z = 0,
                y, x;
            for (y = 0; y < 4; y++) {
                for (x = 0; x < 5; x++) {
                    z = (x === 4) ? m[i + 4] : 0;
                    temp[i + x] = m[i] * m2[x] + m[i + 1] * m2[x + 5] + m[i + 2] * m2[x + 10] + m[i + 3] * m2[x + 15] + z;
                }
                i += 5;
            }
            return temp;
        },

        _setSaturation = function(m, n) {
            if (isNaN(n)) {
                return m;
            }
            var inv = 1 - n,
                r = inv * _lumR,
                g = inv * _lumG,
                b = inv * _lumB;
            return _applyMatrix([r + n, g, b, 0, 0, r, g + n, b, 0, 0, r, g, b + n, 0, 0, 0, 0, 0, 1, 0], m);
        },

        _colorize = function(m, color, amount) {
            if (isNaN(amount)) {
                amount = 1;
            }
            var c = _parseColor(color),
                r = c[0] / 255,
                g = c[1] / 255,
                b = c[2] / 255,
                inv = 1 - amount;
            return _applyMatrix([inv + amount * r * _lumR, amount * r * _lumG, amount * r * _lumB, 0, 0, amount * g * _lumR, inv + amount * g * _lumG, amount * g * _lumB, 0, 0, amount * b * _lumR, amount * b * _lumG, inv + amount * b * _lumB, 0, 0, 0, 0, 0, 1, 0], m);
        },

        _setHue = function(m, n) {
            if (isNaN(n)) {
                return m;
            }
            n *= Math.PI / 180;
            var c = Math.cos(n),
                s = Math.sin(n);
            return _applyMatrix([(_lumR + (c * (1 - _lumR))) + (s * (-_lumR)), (_lumG + (c * (-_lumG))) + (s * (-_lumG)), (_lumB + (c * (-_lumB))) + (s * (1 - _lumB)), 0, 0, (_lumR + (c * (-_lumR))) + (s * 0.143), (_lumG + (c * (1 - _lumG))) + (s * 0.14), (_lumB + (c * (-_lumB))) + (s * -0.283), 0, 0, (_lumR + (c * (-_lumR))) + (s * (-(1 - _lumR))), (_lumG + (c * (-_lumG))) + (s * _lumG), (_lumB + (c * (1 - _lumB))) + (s * _lumB), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], m);
        },

        _setContrast = function(m, n) {
            if (isNaN(n)) {
                return m;
            }
            return _applyMatrix([n, 0, 0, 0, 0.5 * (1 - n), 0, n, 0, 0, 0.5 * (1 - n), 0, 0, n, 0, 0.5 * (1 - n), 0, 0, 0, 1, 0], m);
        },

        _getFilter = function(t, type) {
            var filterClass = _gsScope.PIXI.filters[type],
                filters = t.filters || [],
                i = filters.length,
                filter;
            if (!filterClass) {
                throw ("PixiPlugin error: " + type + " isn't present.");
            }
            while (--i > -1) {
                if (filters[i] instanceof filterClass) {
                    return filters[i];
                }
            }
            filter = new filterClass();
            if (type === "BlurFilter") {
                filter.blur = 0;
            }
            filters.push(filter);
            t.filters = filters;
            return filter;
        },

        _parseColorMatrixFilter = function(t, v, pg) {
            var filter = _getFilter(t, "ColorMatrixFilter"),
                i, matrix, startMatrix;
            startMatrix = filter.matrix;
            if (v.matrix && v.matrix.length === startMatrix.length) {
                matrix = v.matrix;
            } else {
                matrix = _idMatrix.slice();
                if (v.colorize != null) {
                    matrix = _colorize(matrix, v.colorize, Number(v.colorizeAmount));
                }
                if (v.contrast != null) {
                    matrix = _setContrast(matrix, Number(v.contrast));
                }
                if (v.hue != null) {
                    matrix = _setHue(matrix, Number(v.hue));
                }
                if (v.saturation != null) {
                    matrix = _setSaturation(matrix, Number(v.saturation));
                }
                if (v.brightness != null) {
                    matrix = new _gsScope.PIXI.filters.ColorMatrixFilter(matrix);
                    matrix.brightness(Number(v.brightness), true);
                    matrix = matrix.matrix;
                }
            }
            i = matrix.length;
            while (--i > -1) {
                if (matrix[i] !== startMatrix[i]) {
                    pg._addTween(startMatrix, i, startMatrix[i], matrix[i], "pixi_colorMatrixFilter");
                }
            }
            pg._overwriteProps.push("pixi_colorMatrixFilter");
        },


        _xyContexts = "position,scale,skew,pivot,anchor,tilePosition,tileScale".split(","),
        _contexts = {
            x: "position",
            y: "position",
            tileX: "tilePosition",
            tileY: "tilePosition"
        },
        _colorMatrixFilterProps = {
            colorMatrixFilter: 1,
            saturation: 1,
            contrast: 1,
            hue: 1,
            colorize: 1,
            colorizeAmount: 1,
            brightness: 1
        },
        _DEG2RAD = Math.PI / 180,
        _degreesToRadians = function(value) {
            return (typeof(value) === "string" && value.charAt(1) === "=") ? value.substr(0, 2) + (parseFloat(value.substr(2)) * _DEG2RAD) : value * _DEG2RAD;
        },
        i, p;

    for (i = 0; i < _xyContexts.length; i++) {
        p = _xyContexts[i];
        _contexts[p + "X"] = p;
        _contexts[p + "Y"] = p;
    }

    _gsScope._gsDefine.plugin({
        propName: "pixi",
        priority: 0,
        API: 2,
        version: "0.0.3",

        init: function(target, values, tween, index) {
            if (!target instanceof PIXI.DisplayObject) {
                return false;
            }
            var context, axis, value, colorMatrix, filter, p, padding, i;
            for (p in values) {
                context = _contexts[p];
                value = values[p];
                if (typeof(value) === "function") {
                    value = value(index || 0, target);
                }
                if (context) {
                    axis = (p.charAt(p.length - 1).toLowerCase().indexOf("x") !== -1) ? "x" : "y";
                    this._addTween(target[context], axis, target[context][axis], (context === "skew") ? _degreesToRadians(value) : value, p);
                } else if (p === "scale" || p === "anchor" || p === "pivot" || p === "tileScale") {
                    this._addTween(target[p], "x", target[p].x, value, p + "X");
                    this._addTween(target[p], "y", target[p].y, value, p + "Y");
                } else if (p === "rotation") { //PIXI expects rotation in radians, but as a convenience we let folks define it in degrees and we do the conversion.
                    this._addTween(target, p, target.rotation, _degreesToRadians(value), p);

                } else if (_colorMatrixFilterProps[p]) {
                    if (!colorMatrix) {
                        _parseColorMatrixFilter(target, values.colorMatrixFilter || values, this);
                        colorMatrix = true;
                    }
                } else if (p === "blur" || p === "blurX" || p === "blurY" || p === "blurPadding") {
                    filter = _getFilter(target, "BlurFilter");
                    this._addTween(filter, p, filter[p], value, "pixi_" + p);
                    if (values.blurPadding !== 0) {
                        padding = values.blurPadding || Math.max(filter[p], value) * 2;
                        i = target.filters.length;
                        while (--i > -1) {
                            target.filters[i].padding = Math.max(target.filters[i].padding, padding); //if we don't expand the padding on all the filters, it can look clipped.
                        }
                    }
                    this._overwriteProps.push("pixi_" + p);
                } else {
                    this._addTween(target, p, target[p], value, p);
                }
            }
            return true;
        }
    });
});
if (_gsScope._gsDefine) {
    _gsScope._gsQueue.pop()();
}

//export to AMD/RequireJS and CommonJS/Node (precursor to full modular build system coming at a later date)
(function(name) {
    "use strict";
    var getGlobal = function() {
        return (_gsScope.GreenSockGlobals || _gsScope)[name];
    };
    if (typeof(module) !== "undefined" && module.exports) { //node
        require("../TweenLite.js");
        module.exports = getGlobal();
    } else if (typeof(define) === "function" && define.amd) { //AMD
        define(["TweenLite"], getGlobal);
    }
}("PixiPlugin"));